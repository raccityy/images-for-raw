"""
Enhanced Group Messaging System for Telegram Bot

This module handles all group-to-user messaging functionality with comprehensive media support.
Features:
- Support for all media types (photos, videos, GIFs, documents, audio, etc.)
- Continuous reply mode for multiple messages
- Admin commands for managing reply sessions
- Automatic media type detection and forwarding
- Confirmation messages for successful forwards

Admin Commands:
- /exit_reply - Exit continuous reply mode
- /reply_status - Check current reply status
"""

from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from bot_instance import bot
import logging

group_chat_id = -4634368956  # Replace with your actual group chat ID

# Store mapping from group message_id to user chat_id
reply_targets = {}

# Store mapping from admin chat_id to user chat_id for reply flow
admin_reply_state = {}

# Store admin reply modes (for continuous reply mode)
admin_reply_modes = {}

def send_payment_verification_to_group(user, price, ca, tx_hash, user_chat_id=None):
    text = (
        f"this user @{user}\n\n"
        f"selected this {price}\n"
        f"with this ca {ca}\n"
        f"and you are awaiting payment to start working\n"
        f"so please verify this {tx_hash} immediately"
    )
    markup = InlineKeyboardMarkup()
    reply_btn = InlineKeyboardButton("reply", callback_data=f"group_reply_{user_chat_id}")
    close_btn = InlineKeyboardButton("close", callback_data=f"group_close_{user_chat_id}")
    markup.add(reply_btn, close_btn)
    sent = bot.send_message(group_chat_id, text, reply_markup=markup)
    if user_chat_id:
        reply_targets[sent.message_id] = user_chat_id


def handle_group_callback(call):
    if call.data.startswith("group_reply_"):
        # Extract user_chat_id from callback data
        user_chat_id = call.data.split("group_reply_")[1]
        admin_reply_state[call.from_user.id] = user_chat_id
        admin_reply_modes[call.from_user.id] = user_chat_id  # Enable continuous reply mode
        
        # Enhanced reply prompt with media support info
        reply_text = (
            "ğŸ“ **Reply Mode Activated**\n\n"
            "You can now send any of the following to the user:\n"
            "â€¢ ğŸ“ Text messages\n"
            "â€¢ ğŸ–¼ï¸ Photos\n"
            "â€¢ ğŸ¥ Videos\n"
            "â€¢ ğŸ¬ GIFs/Animations\n"
            "â€¢ ğŸ“„ Documents\n"
            "â€¢ ğŸµ Audio files\n"
            "â€¢ ğŸ¤ Voice messages\n"
            "â€¢ ğŸ“ Locations\n"
            "â€¢ ğŸ‘¤ Contacts\n"
            "â€¢ ğŸ² Stickers\n\n"
            "ğŸ’¡ **Commands:**\n"
            "â€¢ `/exit_reply` - Stop replying to this user\n"
            "â€¢ `/reply_status` - Check current reply status\n\n"
            "Send your message now..."
        )
        bot.send_message(call.message.chat.id, reply_text, parse_mode="Markdown")
        
    elif call.data.startswith("group_close_"):
        bot.delete_message(call.message.chat.id, call.message.message_id)

# Handler to process admin replies in the group (called from main.py)
def handle_admin_reply(message):
    admin_id = message.from_user.id
    print(f"DEBUG: Group message received from admin {admin_id}, content type: {message.content_type}")
    
    # Handle admin commands
    if message.text:
        command = message.text.strip()
        
        if command == "/exit_reply":
            if admin_id in admin_reply_modes:
                user_chat_id = admin_reply_modes.pop(admin_id)
                admin_reply_state.pop(admin_id, None)  # Also remove from single reply state
                bot.send_message(message.chat.id, f"âœ… Exited reply mode for user {user_chat_id}")
            else:
                bot.send_message(message.chat.id, "âŒ You're not currently in reply mode")
            return
        
        elif command == "/reply_status":
            if admin_id in admin_reply_modes:
                user_chat_id = admin_reply_modes[admin_id]
                bot.send_message(message.chat.id, f"ğŸ“ Currently in continuous reply mode for user {user_chat_id}")
            elif admin_id in admin_reply_state:
                user_chat_id = admin_reply_state[admin_id]
                bot.send_message(message.chat.id, f"ğŸ“ Currently in single reply mode for user {user_chat_id}")
            else:
                bot.send_message(message.chat.id, "âŒ Not currently in reply mode")
            return
    
    # Handle single reply mode (one-time reply)
    if admin_id in admin_reply_state and admin_id not in admin_reply_modes:
        user_chat_id = admin_reply_state.pop(admin_id)
        
        # Forward the message to user with enhanced media support
        handle_media_forwarding_with_confirmation(message, user_chat_id)
        
        # Note: Confirmation is now handled by handle_media_forwarding_with_confirmation
        # so we don't need the simple "Reply sent to user" message here
    
    # Handle continuous reply mode
    elif admin_id in admin_reply_modes:
        user_chat_id = admin_reply_modes[admin_id]
        
        # Forward the message to user with enhanced media support
        handle_media_forwarding_with_confirmation(message, user_chat_id)

def forward_message_to_user(message, user_chat_id):
    """Forward admin message to user, supporting all media types"""
    try:
        print(f"DEBUG: Forwarding message to user {user_chat_id}, content type: {message.content_type}")
        print(f"DEBUG: Message has photo: {bool(message.photo)}, video: {bool(message.video)}, text: {bool(message.text)}")
        
        # Handle photos (prioritize media over text)
        if message.photo:
            print("DEBUG: Processing photo message")
            # Get the highest quality photo
            photo = message.photo[-1]
            bot.send_photo(user_chat_id, photo.file_id, caption=message.caption)
        
        # Handle videos
        elif message.video:
            print("DEBUG: Processing video message")
            bot.send_video(user_chat_id, message.video.file_id, caption=message.caption)
        
        # Handle animations (GIFs)
        elif message.animation:
            print("DEBUG: Processing animation message")
            bot.send_animation(user_chat_id, message.animation.file_id, caption=message.caption)
        
        # Handle documents
        elif message.document:
            print("DEBUG: Processing document message")
            bot.send_document(user_chat_id, message.document.file_id, caption=message.caption)
        
        # Handle audio
        elif message.audio:
            print("DEBUG: Processing audio message")
            bot.send_audio(user_chat_id, message.audio.file_id, caption=message.caption)
        
        # Handle voice messages
        elif message.voice:
            print("DEBUG: Processing voice message")
            bot.send_voice(user_chat_id, message.voice.file_id, caption=message.caption)
        
        # Handle video notes (round videos)
        elif message.video_note:
            print("DEBUG: Processing video note message")
            bot.send_video_note(user_chat_id, message.video_note.file_id)
        
        # Handle stickers
        elif message.sticker:
            print("DEBUG: Processing sticker message")
            bot.send_sticker(user_chat_id, message.sticker.file_id)
        
        # Handle location
        elif message.location:
            print("DEBUG: Processing location message")
            bot.send_location(user_chat_id, message.location.latitude, message.location.longitude)
        
        # Handle contact
        elif message.contact:
            print("DEBUG: Processing contact message")
            bot.send_contact(user_chat_id, message.contact.phone_number, message.contact.first_name)
        
        # Handle poll (if supported by telebot version)
        elif hasattr(message, 'poll') and message.poll:
            print("DEBUG: Processing poll message")
            bot.send_poll(user_chat_id, message.poll.question, message.poll.options, is_anonymous=message.poll.is_anonymous)
        
        # Handle dice (if supported by telebot version)
        elif hasattr(message, 'dice') and message.dice:
            print("DEBUG: Processing dice message")
            bot.send_dice(user_chat_id, emoji=message.dice.emoji)
        
        # Handle venue (if supported by telebot version)
        elif hasattr(message, 'venue') and message.venue:
            print("DEBUG: Processing venue message")
            bot.send_venue(user_chat_id, message.venue.location.latitude, message.venue.location.longitude, 
                          message.venue.title, message.venue.address)
        
        # Handle text messages (only if no media is present)
        elif message.text:
            print("DEBUG: Processing text message")
            bot.send_message(user_chat_id, message.text)
        
        else:
            print("DEBUG: Unsupported message type")
            # Fallback for unsupported content types
            bot.send_message(user_chat_id, "Received unsupported message type from admin.")
            
    except Exception as e:
        # Send error message to user if forwarding fails
        bot.send_message(user_chat_id, f"Error forwarding message: {str(e)}")
        print(f"Error forwarding message to user {user_chat_id}: {e}")

def get_media_type_info(message):
    """Get information about the media type of a message"""
    if message.photo:
        return "ğŸ“· Photo"
    elif message.video:
        return "ğŸ¥ Video"
    elif message.animation:
        return "ğŸ¬ Animation/GIF"
    elif message.document:
        return "ğŸ“„ Document"
    elif message.audio:
        return "ğŸµ Audio"
    elif message.voice:
        return "ğŸ¤ Voice Message"
    elif message.video_note:
        return "ğŸ“¹ Video Note"
    elif message.sticker:
        return "ğŸ² Sticker"
    elif message.location:
        return "ğŸ“ Location"
    elif message.contact:
        return "ğŸ‘¤ Contact"
    elif hasattr(message, 'poll') and message.poll:
        return "ğŸ“Š Poll"
    elif hasattr(message, 'dice') and message.dice:
        return "ğŸ² Dice"
    elif hasattr(message, 'venue') and message.venue:
        return "ğŸ¢ Venue"
    elif message.text:
        return "ğŸ“ Text"
    else:
        return "â“ Unknown"

def send_media_confirmation_to_group(admin_id, user_chat_id, media_type):
    """Send confirmation to group when media is forwarded"""
    try:
        confirmation_text = f"âœ… {media_type} forwarded to user (ID: {user_chat_id})"
        bot.send_message(group_chat_id, confirmation_text)
    except Exception as e:
        print(f"Error sending confirmation to group: {e}")

def handle_media_forwarding_with_confirmation(message, user_chat_id):
    """Enhanced media forwarding with confirmation"""
    media_type = get_media_type_info(message)
    
    # Forward the message
    forward_message_to_user(message, user_chat_id)
    
    # Send confirmation to group
    send_media_confirmation_to_group(message.from_user.id, user_chat_id, media_type)
